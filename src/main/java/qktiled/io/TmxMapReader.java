package qktiled.io;

import org.eclipse.collections.api.list.ImmutableList;
import org.eclipse.collections.impl.list.mutable.FastList;
import org.w3c.dom.Document;
import org.w3c.dom.NamedNodeMap;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import qktiled.*;
import qktiled.object.ObjectGroup;
import qktiled.object.TileObject;
import qktiled.object.TileObjectType;

import javax.xml.parsers.DocumentBuilderFactory;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.stream.Collectors;
import java.util.zip.DataFormatException;
import java.util.zip.Inflater;
import java.util.zip.InflaterInputStream;

import java.util.Base64;

import static util.XmlUtil.asList;

/**
 * <code>TmxMapReader</code> reads the map file generated by Tiled.
 */
public class TmxMapReader {


    private static String getAttributeValue(Node node, String attrName) {
        final NamedNodeMap attributes = node.getAttributes();
        String value = null;
        if (attributes != null) {
            Node attribute = attributes.getNamedItem(attrName);
            if (attribute != null) {
                value = attribute.getNodeValue();
            }
        }
        return value;
    }

    private static int getAttribute(Node node, String attrName, int def) {
        final String attr = getAttributeValue(node, attrName);
        if (attr != null) {
            return Integer.parseInt(attr);
        } else {
            return def;
        }
    }

    private static long getAttribute(Node node, String attrName, long def){
        final String attr = getAttributeValue(node, attrName);
        return (attr != null ? Long.parseLong(attr) : def);
    }
    /**
     * Returns the first valid Node (ELEMENT_NODE) in the node childs.
     *
     * @param node
     * @return the first ELEMENT_NODE founded, null otherwise.
     */
    private static Node getFirstValidChildNode(Node node) {
        NodeList nl = node.getChildNodes();

        for (Node n : asList(nl)) {
            if (n.getNodeType() == Node.ELEMENT_NODE)
                return n;
        }

        return null;
    }

    /**
     * Returns an <code>ImmutableList</code> with all valid nodes.
     *
     * @param nodeList
     * @return all the ELEMENT_NODE founded in the NodeList.
     */
    private static ImmutableList<Node> getValidsChildsNodes(NodeList nodeList) {
        return asList(nodeList).stream().filter(n -> n.getNodeType() == Node.ELEMENT_NODE).collect(Collectors.toCollection(FastList::new)).toImmutable();
    }

    private static TileObjectType getObjectType(Node n) {
        String type = getAttributeValue(n, "type");

        if (type != null)
            return new TileObjectType(type);
        else
            return new TileObjectType("");
    }

    private static int[] getData(Node node, int mapWidth, int mapHeight) throws IOException {
        String value = node.getTextContent();
        String[] grid = value.trim().split("[\\s]*,[\\s]*");

        if (grid.length != mapHeight * mapWidth)
            throw new IOException("Number of tiles does not match the layer's width and height");

        int[] out = new int[mapWidth * mapHeight];
        int i = 0;
        for (int x = 0; x < mapWidth; x++) {
            for (int y = 0; y < mapHeight; y++) {
                out[i++] = Integer.parseInt(grid[x + y * mapWidth]);
            }
        }

        return out;
    }

    private static String getBase64Data(Node node) {
        return node.getTextContent().trim();
    }

    /**
     * <p>Helper method to read all byte(s) from a {@link InputStream}</p>
     * @throws IOException
     */
    private static int readAll(InputStream input, byte[] data) throws IOException {
        int length = data.length;
        int offset = 0;

        while (length > 0) {
            final int read = input.read(data, offset, length);

            length -= read;
            offset += read;
        }
        return offset;
    }

    private static Data getLayerData(Node node, int mapWidth, int mapHeight) throws IOException, DataFormatException {
        String encoding = getAttributeValue(getFirstValidChildNode(node), "encoding");

        switch (encoding) {
            case "xml":
                throw new IOException("Not implemented yet.");
            case "csv":
                return new Data(getData(getFirstValidChildNode(node), mapWidth, mapHeight));
            case "base64":
                String compression = getAttributeValue(getFirstValidChildNode(node), "compression");
                String encData = getBase64Data(getFirstValidChildNode(node));
                byte[] decData = Base64.getDecoder().decode(encData.getBytes());

                int size = mapWidth * mapHeight * 4;

                InputStream is;

                byte[] data = new byte[size];

                if (compression != null)
                    switch (compression) {
                        case "zlib":
                            decData = decompress(decData);
                            break;
                    }


                is = new ByteArrayInputStream(decData);

                if (readAll(is, data) != size)
                    System.out.println("Buffer mismatches map size");

                int[] grid = new int[mapWidth * mapHeight];
                int tileId;
                int j = 0;

                for(int i = 0; i < size - 3; i +=4) {
                    tileId = data[i] |
                            data[i + 1] << 8 |
                            data[i + 2] << 16 |
                            data[i + 3] << 24;

                    grid[j++] = tileId;
                }

                return new Data(grid);

            default:
                throw new IOException("Undefined encoding.");
        }
    }

    private static byte[] decompress(byte[] data) throws DataFormatException, IOException {
        Inflater decompresser = new Inflater();
        decompresser.setInput(data);
        ByteArrayOutputStream outputStream = new ByteArrayOutputStream(data.length);

        byte[] buffer = new byte[1024];

        while (!decompresser.finished()) {
            int count = decompresser.inflate(buffer);
            outputStream.write(buffer, 0, count);
        }
        outputStream.close();

        return outputStream.toByteArray();
    }
    /**
     * @param in
     * @return A new instance of Map containing the data of the tiled file.
     * @throws Exception
     */
    public Map load(InputStream in) throws Exception {
        Map map = new Map();
        Node mapNode;

        //Dom parsing
        Document doc = DocumentBuilderFactory.newInstance()
                .newDocumentBuilder()
                .parse(in);

        mapNode = doc.getDocumentElement();

        if (!"map".equals(mapNode.getNodeName()))
            throw new Exception("Not a valid tmx map.");

        /**
         * Loads the map attributes
         */
        map.setVersion(getAttributeValue(mapNode, "version"));
        map.setMapWidth(getAttribute(mapNode, "width", 0));
        map.setMapHeight(getAttribute(mapNode, "height", 0));
        map.setTileWidth(getAttribute(mapNode, "tilewidth", 0));
        map.setTileHeight(getAttribute(mapNode, "tileheight", 0));
        map.setNextObjectId(getAttribute(mapNode, "nextobjectid", 0));

        NodeList nl = doc.getElementsByTagName("tileset");


        /**
         * Loads the tilesets
         */
        for (Node n : asList(nl)) {
            map.addTileSet(new TileSet(getAttribute(n, "firstgid", 0),
                    getAttributeValue(n, "name"),
                    new TileSetImage(getAttributeValue(getFirstValidChildNode(n), "source"),
                            getAttribute(getFirstValidChildNode(n), "width", 0),
                            getAttribute(getFirstValidChildNode(n), "height", 0)),
                    getAttribute(n, "tilewidth", 0),
                    getAttribute(n, "tileheight", 0),
                    getAttribute(n, "tilecount", 0),
                    getAttribute(n, "columns", 0)));
        }

        /**
         * Loads the layers
         */
        nl = doc.getElementsByTagName("layer");

        for (Node n : asList(nl)) {
            int w, h;
            w = getAttribute(n, "width", 0);
            h = getAttribute(n, "height", 0);
            map.addLayer(new Layer(getAttributeValue(n, "name"),
                    w,
                    h,
                    getLayerData(n, w, h)));
        }

        /**
         * Loads the objects groups
         */

        nl = doc.getElementsByTagName("objectgroup");
        for (Node n : asList(nl)) {
            ObjectGroup og = new ObjectGroup(getAttributeValue(n, "name"));

            for (Node nn : getValidsChildsNodes(n.getChildNodes())) {
                og.addObject(new TileObject(getAttribute(nn, "id", 0),
                        getAttribute(nn, "gid", (long)0),
                        getAttribute(nn, "x", 0),
                        getAttribute(nn, "y", 0),
                        getAttribute(nn, "width", 0),
                        getAttribute(nn, "height", 0),
                        getAttribute(nn, "visible", 0) == 0 ? false : true,
                        getObjectType(nn)));
            }
            map.addObjectGroup(og);
        }
        return map;
    }
}