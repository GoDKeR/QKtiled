package qktiled.io;

import org.eclipse.collections.api.list.ImmutableList;
import org.eclipse.collections.api.list.MutableList;
import org.eclipse.collections.impl.list.mutable.FastList;
import org.w3c.dom.Document;
import org.w3c.dom.NamedNodeMap;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import qktiled.*;
import qktiled.object.ObjectGroup;
import qktiled.object.TileObject;
import qktiled.object.TileObjectType;

import javax.xml.parsers.DocumentBuilderFactory;
import java.io.InputStream;
import java.util.stream.Collectors;

import static util.XmlUtil.asList;

/**
 * <code>TmxMapReader</code> reads the map file generated by Tiled.
 */
public class TmxMapReader {

    private static String getAttributeValue(Node node, String attrName) {
        final NamedNodeMap attributes = node.getAttributes();
        String value = null;
        if (attributes != null) {
            Node attribute = attributes.getNamedItem(attrName);
            if (attribute != null) {
                value = attribute.getNodeValue();
            }
        }
        return value;
    }

    private static int getAttribute(Node node, String attrName, int def) {
        final String attr = getAttributeValue(node, attrName);
        if (attr != null) {
            return Integer.parseInt(attr);
        } else {
            return def;
        }
    }

    /**
     * Returns the first valid Node (ELEMENT_NODE) in the node childs.
     *
     * @param node
     * @return the first ELEMENT_NODE founded, null otherwise.
     */
    private static Node getFirstValidChildNode(Node node) {
        NodeList nl = node.getChildNodes();

        for (Node n : asList(nl)) {
            if (n.getNodeType() == Node.ELEMENT_NODE)
                return n;
        }

        return null;
    }

    /**
     * Returns an <code>ImmutableList</code> with all valid nodes.
     * @param nodeList
     * @return all the ELEMENT_NODE founded in the NodeList.
     */
    private static ImmutableList<Node> getValidsChildsNodes(NodeList nodeList){
        return asList(nodeList).stream().filter(n -> n.getNodeType() == Node.ELEMENT_NODE).collect(Collectors.toCollection(FastList::new)).toImmutable();
    }

    private static TileObjectType getObjectType(Node n){
       String type = getAttributeValue(n, "type");

        if (type != null)
            return new TileObjectType(type);
        else
            return new TileObjectType("");
    }
    private static String[] getData(Node node) {
        String value = node.getTextContent();

        return value.trim().split("[\\s]*,[\\s]*");
    }

    /**
     * @param in
     * @return A new instance of Map containing the data of the tiled file.
     * @throws Exception
     */
    public Map load(InputStream in) throws Exception {
        Map map = new Map();
        Node mapNode;

        //Dom parsing
        Document doc = DocumentBuilderFactory.newInstance()
                .newDocumentBuilder()
                .parse(in);

        mapNode = doc.getDocumentElement();

        if (!"map".equals(mapNode.getNodeName()))
            throw new Exception("Not a valid tmx map.");

        /**
         * Loads the map attributes
         */
        map.setVersion(getAttributeValue(mapNode, "version"));
        map.setMapWidth(getAttribute(mapNode, "width", 0));
        map.setMapHeight(getAttribute(mapNode, "height", 0));
        map.setTileWidth(getAttribute(mapNode, "tilewidth", 0));
        map.setTileHeight(getAttribute(mapNode, "tileheight", 0));
        map.setNextObjectId(getAttribute(mapNode, "nextobjectid", 0));

        NodeList nl = doc.getElementsByTagName("tileset");


        /**
         * Loads the tilesets
         */
        for (Node n : asList(nl)) {
            map.addTileSet(new TileSet(getAttribute(n, "firstgid", 0),
                    getAttributeValue(n, "name"),
                    new TileSetImage(getAttributeValue(getFirstValidChildNode(n), "source"),
                            getAttribute(getFirstValidChildNode(n), "width", 0),
                            getAttribute(getFirstValidChildNode(n), "height", 0)),
                    getAttribute(n, "tilewidth", 0),
                    getAttribute(n, "tileheight", 0),
                    getAttribute(n, "tilecount", 0),
                    getAttribute(n, "columns", 0)));
        }

        /**
         * Loads the layers
         */
        nl = doc.getElementsByTagName("layer");

        for (Node n : asList(nl)) {
            map.addLayer(new Layer(getAttributeValue(n, "name"),
                    getAttribute(n, "width", 0),
                    getAttribute(n, "height", 0),
                    new Data(getAttributeValue(getFirstValidChildNode(n), "encoding"),
                            getData(getFirstValidChildNode(n)))));
        }

        /**
         * Loads the objects groups
         */

        nl = doc.getElementsByTagName("objectgroup");
        for (Node n : asList(nl)){
            ObjectGroup og = new ObjectGroup();

            for (Node nn : getValidsChildsNodes(n.getChildNodes())){
                og.addObject(new TileObject(getAttribute(nn,"id",0),
                        getAttribute(nn,"gid",0),
                        getAttribute(nn, "x", 0),
                        getAttribute(nn, "y", 0),
                        getAttribute(nn, "width", 0),
                        getAttribute(nn, "height", 0),
                        getAttribute(nn, "visible", 0) == 0 ? false : true,
                        getObjectType(nn)));
            }

            map.addObjectGroup(og);
        }
        return map;
    }
}